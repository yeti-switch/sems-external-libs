diff -c5 -r a/src/lib/tls/tls12/tls_channel_impl_12.cpp b/src/lib/tls/tls12/tls_channel_impl_12.cpp
*** a/src/lib/tls/tls12/tls_channel_impl_12.cpp	2023-05-26 01:51:41.236304063 +0300
--- b/src/lib/tls/tls12/tls_channel_impl_12.cpp	2023-05-26 01:55:01.684880698 +0300
***************
*** 344,353 ****
--- 344,360 ----
                 }
              else if(auto pending = pending_state())
                 {
                 if(pending->server_hello() != nullptr && record.version() != pending->version())
                    {
+                   if(m_is_datagram && record.type() == Record_Type::Handshake)
+                      {
+                      //ignore Client Hello retransmit
+                      //https://github.com/randombit/botan/issues/2316
+                      //FIXME: should we fix pending sequences marking instead ?
+                      return 0;
+                      }
                    throw TLS_Exception(Alert::ProtocolVersion,
                                           "Received unexpected record version");
                    }
                 }
              else if(auto active = active_state())
diff -c5 -r a/src/lib/x509/x509_ext.cpp b/src/lib/x509/x509_ext.cpp
*** a/src/lib/x509/x509_ext.cpp	2023-05-26 01:51:41.256304120 +0300
--- b/src/lib/x509/x509_ext.cpp	2023-05-26 01:51:49.288327161 +0300
***************
*** 10,19 ****
--- 10,20 ----
  #include <botan/x509_ext.h>
  #include <botan/x509cert.h>
  #include <botan/der_enc.h>
  #include <botan/ber_dec.h>
  #include <botan/hash.h>
+ #include <botan/asn1_obj.h>
  #include <botan/internal/loadstor.h>
  #include <botan/internal/bit_ops.h>
  #include <algorithm>
  #include <set>
  #include <sstream>
***************
*** 65,74 ****
--- 66,78 ----
        return std::make_unique<Cert_Extension::Extended_Key_Usage>();
  
     if(oid == Cert_Extension::Authority_Information_Access::static_oid())
        return std::make_unique<Cert_Extension::Authority_Information_Access>();
  
+    if(oid == Cert_Extension::TNAuthList::static_oid())
+       return std::make_unique<Cert_Extension::TNAuthList>();
+ 
     return nullptr; // unknown
     }
  
  }
  
***************
*** 853,862 ****
--- 857,916 ----
  
  void OCSP_NoCheck::decode_inner(const std::vector<uint8_t>& buf)
     {
     BER_Decoder(buf).verify_end();
     }
+    
+ TNAuthList::TNEntry::TNEntry()
+    {}
+ 
+ TNAuthList::TNEntry::~TNEntry()
+    {}
+ 
+ void TNAuthList::TNEntry::encode_into(DER_Encoder& to) const
+    {}
+ 
+ void TNAuthList::TNEntry::decode_from(class BER_Decoder& ber)
+    {
+       BER_Object obj = ber.get_next_object();
+       if(obj.is_a(TN_ServiceProviderCode, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {
+           //ServiceProviderCode
+           type = TN_ServiceProviderCode;
+           BER_Decoder v(obj.bits(),obj.length());
+           ASN1_String s;
+           s.decode_from(v);
+           spc = s.value();
+       } else if(obj.is_a(TN_TelephoneNumberRange, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {
+           //TelephoneNumberRange
+           type = TN_TelephoneNumberRange;
+           ber.start_sequence();
+           while(ber.more_items()) {
+               range.emplace_back();
+               auto &range_entry = range.back();
+               ASN1_String s;
+               s.decode_from(ber);
+               range_entry.start = s.value();
+               ber.decode(range_entry.count);
+           }
+           ber.end_cons();
+       } else if(obj.is_a(TN_TelephoneNumber, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {
+           //TelephoneNumber
+           type = TN_TelephoneNumber;
+           BER_Decoder v(obj.bits(),obj.length());
+           ASN1_String s;
+           s.decode_from(v);
+           one = s.value();
+       } else {
+           throw Decoding_Error("unexpected TNEntry type");
+       }
+    }
+ 
+ void TNAuthList::decode_inner(const std::vector<uint8_t>& in)
+    {
+    m_size = in.size();
+    BER_Decoder(in).decode_list(m_tn_entries).verify_end();
+    }
  
  std::vector<uint8_t> Unknown_Extension::encode_inner() const
     {
     return m_bytes;
     }
diff -c5 -r a/src/lib/x509/x509_ext.h b/src/lib/x509/x509_ext.h
*** a/src/lib/x509/x509_ext.h	2023-05-26 01:51:41.256304120 +0300
--- b/src/lib/x509/x509_ext.h	2023-05-26 01:51:49.276327127 +0300
***************
*** 7,17 ****
--- 7,21 ----
  
  #ifndef BOTAN_X509_EXTENSIONS_H_
  #define BOTAN_X509_EXTENSIONS_H_
  
  #include <botan/pkix_types.h>
+ #include <botan/asn1_obj.h>
  #include <set>
+ #include <string>
+ #include <vector>
+ #include <memory>
  
  namespace Botan {
  
  class X509_Certificate;
  
***************
*** 482,491 ****
--- 486,561 ----
        std::vector<uint8_t> encode_inner() const override { return {}; }
        void decode_inner(const std::vector<uint8_t>&) override;
     };
  
  /**
+ * TNAuthList extension
+ *
+ * https://datatracker.ietf.org/doc/html/rfc8226
+ */
+ class TNAuthList final : public Certificate_Extension
+    {
+    public:
+       class TNEntry final : public ASN1_Object
+          {
+          public:
+             enum Type {
+               TN_ServiceProviderCode = 0,
+               TN_TelephoneNumberRange,
+               TN_TelephoneNumber
+             };
+             struct TelephoneNumberRange {
+                std::string start;   //TelephoneNumber (IA5String)
+                size_t count;        //2..MAX
+             };
+ 
+             TNEntry();
+             ~TNEntry();
+ 
+             void encode_into(DER_Encoder& to) const override;
+             void decode_from(class BER_Decoder& from) override;
+ 
+             Type get_type() const { return type; }
+ 
+             const std::string& getServiceProviderCode() const
+             { return spc; }
+ 
+             const std::vector<TelephoneNumberRange>& getTelephoneNumberRange() const
+             { return range; }
+ 
+             const std::string& getTelephoneNumber() const
+             { return one; }
+ 
+          private:
+             Type type;
+             std::string spc;                         //ServiceProviderCode
+             std::vector<TelephoneNumberRange> range; //TelephoneNumberRange
+             std::string one;                         //TelephoneNumber
+          };
+ 
+       TNAuthList() = default;
+ 
+       std::unique_ptr<Certificate_Extension> copy() const override { return std::make_unique<TNAuthList>(); }
+       static OID static_oid() { return OID("1.3.6.1.5.5.7.1.26"); }
+       OID oid_of() const override { return static_oid(); }
+ 
+       size_t get_size() const { return m_size; }
+       const std::vector<TNEntry>& get_entries() const { return m_tn_entries; }
+ 
+    private:
+       std::string oid_name() const override
+        { return "X509v3.TNAuthList"; }
+ 
+       bool should_encode() const override { return false; }
+       std::vector<uint8_t> encode_inner() const override { return {}; }
+       void decode_inner(const std::vector<uint8_t>&) override;
+ 
+       size_t m_size;
+       std::vector<TNEntry> m_tn_entries;
+    };
+ 
+ /**
  * An unknown X.509 extension
  * Will add a failure to the path validation result, if critical
  */
  class BOTAN_PUBLIC_API(2,4) Unknown_Extension final : public Certificate_Extension
     {
