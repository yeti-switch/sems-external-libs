diff --git a/src/lib/tls/tls12/tls_channel_impl_12.cpp b/src/lib/tls/tls12/tls_channel_impl_12.cpp
index 5adcc7de7..98aea66e0 100644
--- a/src/lib/tls/tls12/tls_channel_impl_12.cpp
+++ b/src/lib/tls/tls12/tls_channel_impl_12.cpp
@@ -316,6 +316,11 @@ size_t Channel_Impl_12::from_peer(std::span<const uint8_t> data) {
          BOTAN_ASSERT_IMPLICATION(epoch0_restart, allow_epoch0_restart, "Allowed state");
 
          const bool initial_record = epoch0_restart || (!pending_state() && !active_state());
+         bool initial_handshake_message = false;
+         if(record.type() == Record_Type::Handshake && !m_record_buf.empty()) {
+            Handshake_Type type = static_cast<Handshake_Type>(m_record_buf[0]);
+            initial_handshake_message = (type == Handshake_Type::ClientHello);
+         }
 
          if(record.type() != Record_Type::Alert) {
             if(initial_record) {
@@ -324,11 +329,12 @@ size_t Channel_Impl_12::from_peer(std::span<const uint8_t> data) {
                   throw TLS_Exception(Alert::ProtocolVersion, "Received unexpected record version in initial record");
                }
             } else if(auto pending = pending_state()) {
-               if(pending->server_hello() != nullptr && record.version() != pending->version()) {
+               if(pending->server_hello() != nullptr && !initial_handshake_message &&
+                  record.version() != pending->version()) {
                   throw TLS_Exception(Alert::ProtocolVersion, "Received unexpected record version");
                }
             } else if(auto active = active_state()) {
-               if(record.version() != active->version()) {
+               if(record.version() != active->version() && !initial_handshake_message) {
                   throw TLS_Exception(Alert::ProtocolVersion, "Received unexpected record version");
                }
             }
diff --git a/src/lib/x509/x509_ext.cpp b/src/lib/x509/x509_ext.cpp
index 60ef4cce2..6813d14a4 100644
--- a/src/lib/x509/x509_ext.cpp
+++ b/src/lib/x509/x509_ext.cpp
@@ -12,6 +12,7 @@
 #include <botan/ber_dec.h>
 #include <botan/der_enc.h>
 #include <botan/hash.h>
+#include <botan/asn1_obj.h>
 #include <botan/x509cert.h>
 #include <botan/internal/bit_ops.h>
 #include <botan/internal/loadstor.h>
@@ -80,6 +81,9 @@ std::unique_ptr<Certificate_Extension> extension_from_oid(const OID& oid) {
       return std::make_unique<Cert_Extension::Authority_Information_Access>();
    }
 
+   if(oid == Cert_Extension::TNAuthList::static_oid())
+      return std::make_unique<Cert_Extension::TNAuthList>();
+
    return nullptr;  // unknown
 }
 
@@ -799,6 +803,56 @@ void OCSP_NoCheck::decode_inner(const std::vector<uint8_t>& buf) {
    BER_Decoder(buf).verify_end();
 }
 
+TNAuthList::TNEntry::TNEntry()
+   {}
+
+TNAuthList::TNEntry::~TNEntry()
+   {}
+
+void TNAuthList::TNEntry::encode_into(DER_Encoder& to) const
+   {}
+
+void TNAuthList::TNEntry::decode_from(class BER_Decoder& ber)
+   {
+      BER_Object obj = ber.get_next_object();
+      if(obj.is_a(TN_ServiceProviderCode, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {
+          //ServiceProviderCode
+          type = TN_ServiceProviderCode;
+          BER_Decoder v(obj.bits(),obj.length());
+          ASN1_String s;
+          s.decode_from(v);
+          spc = s.value();
+      } else if(obj.is_a(TN_TelephoneNumberRange, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {
+          //TelephoneNumberRange
+          type = TN_TelephoneNumberRange;
+          ber.start_sequence();
+          while(ber.more_items()) {
+              range.emplace_back();
+              auto &range_entry = range.back();
+              ASN1_String s;
+              s.decode_from(ber);
+              range_entry.start = s.value();
+              ber.decode(range_entry.count);
+          }
+          ber.end_cons();
+      } else if(obj.is_a(TN_TelephoneNumber, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {
+          //TelephoneNumber
+          type = TN_TelephoneNumber;
+          BER_Decoder v(obj.bits(),obj.length());
+          ASN1_String s;
+          s.decode_from(v);
+          one = s.value();
+      } else {
+          throw Decoding_Error("unexpected TNEntry type");
+      }
+   }
+
+void TNAuthList::decode_inner(const std::vector<uint8_t>& in)
+   {
+   m_size = in.size();
+   BER_Decoder(in).decode_list(m_tn_entries).verify_end();
+   }
+
 std::vector<uint8_t> Unknown_Extension::encode_inner() const {
    return m_bytes;
 }
diff --git a/src/lib/x509/x509_ext.h b/src/lib/x509/x509_ext.h
index 923e5799b..405e0af11 100644
--- a/src/lib/x509/x509_ext.h
+++ b/src/lib/x509/x509_ext.h
@@ -9,7 +9,11 @@
 #define BOTAN_X509_EXTENSIONS_H_
 
 #include <botan/pkix_types.h>
+#include <botan/asn1_obj.h>
 #include <set>
+#include <string>
+#include <vector>
+#include <memory>
 
 namespace Botan {
 
@@ -500,6 +504,72 @@ class OCSP_NoCheck final : public Certificate_Extension {
       void decode_inner(const std::vector<uint8_t>&) override;
 };
 
+/**
+* TNAuthList extension
+*
+* https://datatracker.ietf.org/doc/html/rfc8226
+*/
+class TNAuthList final : public Certificate_Extension
+   {
+   public:
+      class TNEntry final : public ASN1_Object
+         {
+         public:
+            enum Type {
+              TN_ServiceProviderCode = 0,
+              TN_TelephoneNumberRange,
+              TN_TelephoneNumber
+            };
+            struct TelephoneNumberRange {
+               std::string start;   //TelephoneNumber (IA5String)
+               size_t count;        //2..MAX
+            };
+
+            TNEntry();
+            ~TNEntry();
+
+            void encode_into(DER_Encoder& to) const override;
+            void decode_from(class BER_Decoder& from) override;
+
+            Type get_type() const { return type; }
+
+            const std::string& getServiceProviderCode() const
+            { return spc; }
+
+            const std::vector<TelephoneNumberRange>& getTelephoneNumberRange() const
+            { return range; }
+
+            const std::string& getTelephoneNumber() const
+            { return one; }
+
+         private:
+            Type type;
+            std::string spc;                         //ServiceProviderCode
+            std::vector<TelephoneNumberRange> range; //TelephoneNumberRange
+            std::string one;                         //TelephoneNumber
+         };
+
+      TNAuthList() = default;
+
+      std::unique_ptr<Certificate_Extension> copy() const override { return std::make_unique<TNAuthList>(); }
+      static OID static_oid() { return OID("1.3.6.1.5.5.7.1.26"); }
+      OID oid_of() const override { return static_oid(); }
+
+      size_t get_size() const { return m_size; }
+      const std::vector<TNEntry>& get_entries() const { return m_tn_entries; }
+
+   private:
+      std::string oid_name() const override
+       { return "X509v3.TNAuthList"; }
+
+      bool should_encode() const override { return false; }
+      std::vector<uint8_t> encode_inner() const override { return {}; }
+      void decode_inner(const std::vector<uint8_t>&) override;
+
+      size_t m_size;
+      std::vector<TNEntry> m_tn_entries;
+   };
+
 /**
 * An unknown X.509 extension
 * Will add a failure to the path validation result, if critical
